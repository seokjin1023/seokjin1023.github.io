---
title: Greedy
date: 2025-6-30 12:00:00 +0900
categories: [소프트웨어, 알고리즘]
tags: [Prim's algorithm, kruskal]
math: true
---

# Greedy

### 사용되는 이유

DP의 경우 많은 경우 optimal solution을 제공한다.

하지만, time complexity가 polynomial($O(n^k)$)하기 때문에 실제 running time이 매우 길 수 있음.

이를 보완하고자 상황에 맞는 문제는 greedy로 해결이 가능하다. 

### 정의

만약 local optimal → global optimal로 이어진다면 greedy를 활용할 수 있다.

**각 단계에서의 최적 선택이 전체 문제에 대한 최적 해를 보장**할 때 사용 가능하다.

### 핵심 가치

**Ranking을 매기는 것**

- 이 Rank에 따라서 algorithm의 동작 방식이 각자마다 다르다.

1. **optimal substructure**
2. **local optimal → global optimal** 
    
    ⇒ Greedy > DP
    

### Design Step

**Step 1: Selection ⇒ local optimal choice(by ranking)**

**Step 2: Feasibility(Optional)** 

→ constraint(위의 selection이 문제의 조건을 위배하는지 확인)

**Step 3: Solution check**

→ 원하는 답을 구했는지 확인하고 terminate

### Proof가 필수적인가?

proof를 통한 **증명을 하게 된다면 그 답이 optimal(정답)**이다 라는 것을 보장할 수 있다.

만약 하지 않는다고 해도 **정답을 보장할 수는 없지만** 코드는 동작한다.

**Greedy에서 Induction이 많이 사용되는 이유**

- Greedy는 반복문을 통해 답을 Incremental해나감. ⇒ Induction과 성격 유사

### Greedy가 중요한 이유 3가지

1. natural, simple, fast/easy implement → heuristic한 idea
2. Test-bed : baseline performance 제공
    
    <기준점> → 이후의 접근들에 대한 기준 근거 제공
    
    이유: Greedy는 새로운 문제를 직면했을 때 연구자들이 가장 먼저 접근하는 전략
    
    - 정밀, 정확성 향상의 기초, 속도 증가, model size(memroy complexity) 감소
3. May-be optimal
    
    local optimal → global optimal이라는 proof가 필요하다.
    

## MST를 구하는 2가지 Algorithm

## Prim's algorithm

### Idea

node(vertex)를 중심으로 ranking을 매기고 그에 따라서 연결

```python
G = graph(V, E)
F = {}
Y = {V_1}
while(not solved yet):
	#**Step 1:**
	select v in (V - Y) nearset to Y
	
	#**Step 2: feasibility test
	# MST에서는 cycle을 가지지 않아야 한다.
	# Prim의 algorithm은 현재 Y에 속하지 않는 노드와 연결 => cycle 발생 불가
	# 필요 X
	add v to Y
	
	#Step 3: check is finished
	if(V == Y)
		exit**
```

### Analysis(Time Complexity)

$$
\text{number of vertex is important / n = vertex의 개수} \\
\begin{align*}
T(n) &= (n - 1)(n - 2) \\
&= O(n(n - 1)) \\
&= O(n^2)
\end{align*}

$$

### Proof

**Prim’s theorem**

prim’s algorithm produce MST

**(Base)**

F = empty → empty set도 MST이다.

**(Hypothetis)**

Assume F is promising(MST T=(Y, F))

→ F가 MST라고 가정하는 것.

**(Induction)**

F + next edge is MST

- how to show this is optimal?
    
    ⇒ Proof of Induction 중 하나인 proof of contradiction을 통해 증명
    

Let T = (Y, F) → next MST로 선택된(T_prim(Y + v, F + e)) is not MST

이 의미는 다른 optimal MST인 T_opt(T + v’, F + e’)이 존재한다는 의미임.

여기서 이 알고리즘에 의하면 T_opt는 T_prim보다 총 weight가 적어야 한다.

하지만, e는 V-Y에서 연결된 weight 중 가장 작은 값이므로 e < e’

W(T_opt) > W(T_prim)이므로 이는 모순이다,

결론적으로 F + next edge는 MST가 맞다.

## kruskal

### Idea

edge의 길이를 기준으로 MST를 만든다.

```python
G = (V, E)
init_Set() # |V|개의 disjoint_set을 만들고 연결될 때마다 두 set을 join(connect)
Sort(E) # ascending order
while not solved yet:
	#Step 1
	select next edge 'e' from sorted E
	#Step 2
	#edge를 기준으로 하다보니 이미 이어진 노드들이 연결될 수 있음.
	#check를 통해서 'e'를 add하지 않거나 하거나
	Check the cycle
	#Step 3
	if it's solved:
		stop

```

### Cycle을 찾아내는 방법

Forest data structere를 활용해서 tree의 set들이 있을 때 cycle을 이루는지 확인 가능하다.

**Key Operation**

1. find → find root of tree
2. union → connect two roots

**방법**

i와 j를 연결하는 e가 선택되었다고 하자.

`find(i)` 와 `find(j)`를 통해 각각의 root를 구한다.

`if find(i) == find(j)` ⇒ Cycle이 있다는 의미이므로 그냥 넘어간다.

만약 `find(i) != find(j)` ⇒ add ‘e’를 하고 while문 반복

### Analysis

$$
\text{|V| = n, |E| = m이라고 하자.}\\
\text{Step 1: init(disjoint set)} : \theta(n)\\
\text{Step 2: sort} : m\log m \text{(with specific algo)}\\
\text{Step 3: while-loop} : O(m \times \text{cycle check}) \\

$$

**Cycle check**

각각의 vertex에서 대한 find + union

find의 경우 어떤 data structure를 사용하였느냐에 따라서 다름.

여러 연구 결과 cycle-check에 대한 operation = $\alpha(n, m)$으로 정의됨.

$\alpha(n, m) = m\log n\text{(학부 수준)}$

**결론**

$$
n - 1 \leq m \leq \frac{n(n-1)}{2} \text{이므로} \\
T(n) = \theta(n) + O(m\log m) + O(m\log n) = O(m\log m)
$$

### Proof는 Prim와 비슷함.